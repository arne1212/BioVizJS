/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var vitasight;
/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HeartRateGauge: function() { return /* reexport safe */ _visualizations_heartRate_heartRateGauge_js__WEBPACK_IMPORTED_MODULE_0__.HeartRateGauge; },\n/* harmony export */   HeartRateSketchFigure: function() { return /* reexport safe */ _visualizations_heartRate_heartRateSketchFigure_js__WEBPACK_IMPORTED_MODULE_1__.HeartRateSketchFigure; },\n/* harmony export */   HistoryLineGraph: function() { return /* reexport safe */ _visualizations_heartRate_historyLineGraph_js__WEBPACK_IMPORTED_MODULE_4__.HistoryLineGraph; },\n/* harmony export */   PulsatingHeart: function() { return /* reexport safe */ _visualizations_heartRate_pulsatingHeart_js__WEBPACK_IMPORTED_MODULE_2__.PulsatingHeart; },\n/* harmony export */   ScreenOverlay: function() { return /* reexport safe */ _visualizations_heartRate_screenOverlay_js__WEBPACK_IMPORTED_MODULE_3__.ScreenOverlay; }\n/* harmony export */ });\n/* harmony import */ var _visualizations_heartRate_heartRateGauge_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./visualizations/heartRate/heartRateGauge.js */ \"./src/visualizations/heartRate/heartRateGauge.js\");\n/* harmony import */ var _visualizations_heartRate_heartRateSketchFigure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./visualizations/heartRate/heartRateSketchFigure.js */ \"./src/visualizations/heartRate/heartRateSketchFigure.js\");\n/* harmony import */ var _visualizations_heartRate_pulsatingHeart_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./visualizations/heartRate/pulsatingHeart.js */ \"./src/visualizations/heartRate/pulsatingHeart.js\");\n/* harmony import */ var _visualizations_heartRate_screenOverlay_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./visualizations/heartRate/screenOverlay.js */ \"./src/visualizations/heartRate/screenOverlay.js\");\n/* harmony import */ var _visualizations_heartRate_historyLineGraph_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./visualizations/heartRate/historyLineGraph.js */ \"./src/visualizations/heartRate/historyLineGraph.js\");\n\n\n\n\n\n\n\n//# sourceURL=webpack://vitasight/./src/index.js?");

/***/ }),

/***/ "./src/visualizations/heartRate/heartRateGauge.js":
/*!********************************************************!*\
  !*** ./src/visualizations/heartRate/heartRateGauge.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HeartRateGauge: function() { return /* binding */ HeartRateGauge; }\n/* harmony export */ });\n/* harmony import */ var _heartRateVisualization_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./heartRateVisualization.js */ \"./src/visualizations/heartRate/heartRateVisualization.js\");\n/* harmony import */ var _utility_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utility.js */ \"./src/visualizations/utility.js\");\n\n\n\n\n/**\n * Gauge to visualize heart rate values\n * @class\n */\nclass HeartRateGauge extends _heartRateVisualization_js__WEBPACK_IMPORTED_MODULE_0__.HeartRateVisualization {\n  /**\n   * \n   * @constructor\n   * @param {string} containerId \n   * @param {object} options \n   */\n  constructor(containerId) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(containerId, options);\n    this.validateAndSetOptions(options);\n    this.draw();\n  }\n  validateAndSetOptions(options) {\n    const defaultMinVal = 40;\n    const defaultMaxVal = 180;\n    this.colors = 'colors' in options ? options.colors : null;\n    if ('minValue' in options) {\n      if (typeof options.minValue !== 'number' || options.minValue < 0) {\n        throw new Error('minValue must be a number that is at least 0');\n      }\n      this.minVal = options.minValue;\n    } else {\n      this.minVal = defaultMinVal;\n    }\n    if ('maxValue' in options) {\n      if (typeof options.minValue !== 'number' || options.maxValue < 1) {\n        throw new Error('maxValue must be a number that is at least 1');\n      }\n      this.maxVal = options.maxValue;\n    } else {\n      this.maxVal = defaultMaxVal;\n    }\n    if (this.minVal > this.maxVal) {\n      var errorMessage = `Minimum value ${this.minVal} must not be larger than maximum value ${this.maxVal}. Minimum value is set to default=${defaultMinVal} and maximum value to default=${defaultMaxVal}`;\n      this.minVal = defaultMinVal;\n      this.maxVal = defaultMaxVal;\n      console.error(errorMessage);\n    }\n    if (this.referenceVal < this.minVal || this.referenceVal > this.maxVal) {\n      var errorMessage = `Reference value ${this.referenceVal} must be between minimum value ${this.minVal} and maximum value ${this.maxVal}`;\n      this.referenceVal = null;\n      console.error(errorMessage);\n    }\n    if ('showReferenceLine' in options && typeof options.showReferenceLine == \"boolean\") {\n      this.showReferenceLine = options.showReferenceLine;\n    } else {\n      this.showReferenceLine = true;\n    }\n  }\n\n  /**\n   * draws an svg onto the containers canvas\n   */\n  draw() {\n    // dynamic determination of colors to use for svg elements, depending on container color, for sufficient contrast\n    const svgBaseColor = this.getSVGBaseColor();\n    const containerBackgroundColor = this.findBackgroundColor(this.container);\n\n    // define the gradient to use for the gauge\n    // either a gradient definiton is provided by the client in the form [{color: \"\", deg: \"\"}, {color: \"\", deg: \"\"} ...]\n    // or a default gradient definition is used\n    var referenceValueAngle = (this.referenceVal - this.minVal) / (this.maxVal - this.minVal) * 180;\n    var remainingAngle = 180 - referenceValueAngle;\n    let def;\n    var gradientString = (def = this.parseGradientDefinition()) ? def :\n    //default gradient definition\n    `, deepskyblue ${referenceValueAngle / 4}deg, aqua ${2 * (referenceValueAngle / 4)}deg, mediumspringgreen ${3 * (referenceValueAngle / 4)}deg, lime ${referenceValueAngle}deg, greenyellow ${remainingAngle / 4 + referenceValueAngle}deg, yellow ${2 * (remainingAngle / 4) + referenceValueAngle}deg, orange ${3 * (remainingAngle / 4) + referenceValueAngle}deg, red 180deg`;\n    const svgCode = `\n        <svg width=\"100%\" height=\"100%\" viewBox=\"-1 -1 102 60\" xmlns=\"http://www.w3.org/2000/svg\" font-size=\"10\">\n            <defs>\n                <clipPath id=\"circle-clip\">\n                    <path d=\"M 0 50 A 50 50 0 0 1 100 50 V 50 H 0 Z\" />\n                </clipPath>\n            </defs>\n\n            <foreignObject width=\"100\" height=\"50\" clip-path=\"url(#circle-clip)\">\n                <div xmlns=\"http://www.w3.org/1999/xhtml\" style=\"width: 100%; height: 100%; background: conic-gradient(from 270deg at 50% 100% ${gradientString});\"></div>\n            </foreignObject>\n\n            <path id=\"gauge-mask\" d=\"M95 50 C95 25 75 5 50 5 C25 5 5 25 5 50\"\n                fill=\"none\"\n                stroke=\"${containerBackgroundColor}\" \n                stroke-width=\"10\" \n                stroke-linecap=\"butt\"\n                stroke-dasharray=\"141.51956176757812\" \n                stroke-dashoffset=\"0\"\n                style=\"transition: stroke-dashoffset 0.2s ease-in-out;\"\n                />\n\n            \n            \n            <circle id=\"inner-gauge\" cx=\"50\" cy=\"50\" r=\"40\" fill=\"${containerBackgroundColor}\" stroke=\"white\" stroke-width=\"0\"/>\n\n            \n            <path id=\"gauge-stroke\" \n                d=\"M 0 50 H 10 M 90 50 H 100 M 10 50 A 35 35 0 0 1 90 50 M 100 50 A 50 50 0 0 0 0 50\" \n                fill=\"none\" \n                stroke=\"${svgBaseColor}\" \n                stroke-width=\"1\"\n                stroke-linejoin=\"round\"\n                stroke-linecap=\"round\"\n                 /> \n                 \n            \n\n            <circle id=\"needle-circle\" cx=\"50\" cy=\"50\" r=\"3\" fill=\"none\" stroke=\"${svgBaseColor}\" stroke-width=\"0.5\" />\n            <circle id=\"needle-tip-circle\" cx=\"50\" cy=\"50\" r=\"0.5\" fill=\"${svgBaseColor}\" stroke=\"none\" />\n            <line id=\"gauge-needle\" x1=\"50\" y1=\"50\" x2=\"15\" y2=\"50\" stroke=\"${svgBaseColor}\" stroke-width=\"0.5\" stroke-linecap=\"round\" style=\"transition: transform 0.2s ease-in-out;\" />\n            <line id=\"referenceLine\" x1=\"50\" y1=\"45\" x2=\"50\" y2=\"0\" stroke=\"${svgBaseColor}\" stroke-width=\"1\" stroke-dasharray=\"10 35\" stroke-dashoffset=\"10\" visibility=\"${this.showReferenceLine ? 'visible' : 'hidden'}\"/>\n\n            <g id=\"valueDisplay\" visibility=\"${this.valueVisible ? 'visible' : 'hidden'}\">\n                <rect width=\"10\" height=\"8\" x=\"45\" y=\"35\" rx=\"2\" ry=\"2\" fill=\"${containerBackgroundColor}\" stroke=\"${svgBaseColor}\" stroke-width=\"0.5\"/>\n                <text id=\"currentVal\" x=\"50\" y=\"40\" font-size=\"0.6em\" text-anchor=\"middle\" dominant-baseline=\"middle\" fill=\"${svgBaseColor}\" stroke=\"none\">0</text>\n            </g>\n\n            <text id=\"minVal\" x=\"17\" y=\"55\" font-size=\"0.8em\" text-anchor=\"middle\" fill=\"${svgBaseColor}\" stroke=\"none\">${this.minVal}</text>\n            <text id=\"maxVal\" x=\"83\" y=\"55\" font-size=\"0.8em\" text-anchor=\"middle\" fill=\"${svgBaseColor}\" stroke=\"none\">${this.maxVal}</text>\n        </svg>\n        `;\n    // get safe reference to the svg element of the instance to avoid naming conflicts with other DOM elements\n    const tempDiv = document.createElement('div');\n    tempDiv.innerHTML = svgCode;\n    const newSvg = tempDiv.firstElementChild;\n    this.svgElement = newSvg;\n    this.container.appendChild(newSvg);\n    if (this.referenceVal) {\n      this.setReferenceLine(this.referenceVal, this.minVal, this.maxVal);\n    }\n  }\n\n  /**\n   * Parses a string for a css conic-gradient from the clients provided gradient definiton\n   * @returns a string defining a conic-gradient in css syntax\n   */\n  parseGradientDefinition() {\n    if (!this.colors) {\n      // the default gradient definition is will be applied\n      return null;\n    }\n    // arrange the gradient colors based on their degree on the gauge's arch\n    try {\n      this.colors.sort((a, b) => a.deg - b.deg);\n      var gradientString = \"\";\n      for (let color of this.colors) {\n        if (color.color == undefined || color.deg == undefined) {\n          throw new Error(`${color} needs to be a dictionary with the keys color and deg`);\n        }\n        let currentColor = color.color;\n        if (!(0,_utility_js__WEBPACK_IMPORTED_MODULE_1__.isValidColor)(currentColor)) {\n          throw new Error((0,_utility_js__WEBPACK_IMPORTED_MODULE_1__.noValidColorErrorMessage)(currentColor));\n        }\n        let currentDeg = color.deg;\n        gradientString += \",\" + currentColor + \" \" + currentDeg + \"deg\";\n      }\n    } catch (err) {\n      console.error(`Gradient Syntax Error: The gradient definition must be in the form of 'colors = [{color: \"...\", deg: \"...\"}, {color: \"...\", deg: \"...\"}, ...]'.`);\n      return null;\n    }\n    return gradientString;\n  }\n\n  /**\n   * calculates and adjusts the angle of the reference line on the gauge's arch\n   * @param {number} referenceLineVal object attribute for the reference value\n   * @param {number} minHeartRate object attribute for the min heart rate to display\n   * @param {number} maxHeartRate object attribute for the max heart rate to display\n   */\n  setReferenceLine(referenceLineVal, minHeartRate, maxHeartRate) {\n    if (this.svgElement) {\n      const referenceLine = this.svgElement.querySelector('#referenceLine');\n      if (referenceLine) {\n        const fillPercentage = (referenceLineVal - minHeartRate) / (maxHeartRate - minHeartRate);\n        const referenceLineAngle = fillPercentage * 180 - 90;\n        referenceLine.setAttribute('transform', `rotate(${referenceLineAngle} 50 50)`);\n      }\n    }\n  }\n\n  /**\n   * @override\n   * updates the gauge visualization to display a new value\n   * @param {number} heartRate heart rate value to visualize\n   */\n  update(heartRate) {\n    if (!this.svgElement) {\n      return;\n    }\n\n    // keep heart rate display in the defined range\n    if (heartRate > this.maxVal) {\n      heartRate = this.maxVal;\n    }\n    if (heartRate < this.minVal) {\n      heartRate = this.minVal;\n    }\n    // adjust the masking of the gauge by adjusting the dashoffset revealing more or less of the gradient depending on the heart rate value\n    const fillPercentage = (heartRate - this.minVal) / (this.maxVal - this.minVal);\n    const gaugeMask = this.svgElement.querySelector(\"#gauge-mask\");\n    if (gaugeMask) {\n      const maskLength = gaugeMask.getTotalLength();\n      const fillLength = maskLength * fillPercentage;\n      const dashOffset = fillLength;\n      gaugeMask.style.strokeDashoffset = dashOffset;\n    }\n\n    // rotate the needle\n    const gaugeNeedle = this.svgElement.querySelector(\"#gauge-needle\");\n    if (gaugeNeedle) {\n      const needleAngle = fillPercentage * 180;\n      gaugeNeedle.style.transformOrigin = '50px 50px';\n      gaugeNeedle.style.transform = `rotate(${needleAngle}deg)`;\n    }\n\n    // update the displayed value\n    const currentValue = this.svgElement.querySelector('#currentVal');\n    if (currentValue) {\n      currentValue.textContent = heartRate;\n    }\n  }\n}\n\n//# sourceURL=webpack://vitasight/./src/visualizations/heartRate/heartRateGauge.js?");

/***/ }),

/***/ "./src/visualizations/heartRate/heartRateSketchFigure.js":
/*!***************************************************************!*\
  !*** ./src/visualizations/heartRate/heartRateSketchFigure.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HeartRateSketchFigure: function() { return /* binding */ HeartRateSketchFigure; }\n/* harmony export */ });\n/* harmony import */ var _heartRateVisualization_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./heartRateVisualization.js */ \"./src/visualizations/heartRate/heartRateVisualization.js\");\n/* harmony import */ var _utility_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utility.js */ \"./src/visualizations/utility.js\");\n\n\n\n\n/**\n * Sketch figure to visualize heart rate\n * @class\n */\nclass HeartRateSketchFigure extends _heartRateVisualization_js__WEBPACK_IMPORTED_MODULE_0__.HeartRateVisualization {\n  constructor(containerId) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(containerId, options);\n    this.isAnimated;\n    // the percentage amount the heart rate needs to diverge from the referenceValue in order to change the color\n    // multiples of 5% offset will lead to color change by default\n    this.levelOffset;\n    this.colorSteps;\n    this.referenceColorIndex;\n\n    // class constants for the y values of the highest and lowest level\n    this.minY = 89;\n    this.maxY = 176;\n    this.currentY = this.maxY; // Neue Eigenschaft\n    this.phase = 0; // Neue Eigenschaft\n\n    this.validateAndSetOptions(options);\n    this.draw();\n    console.log(\"index\" + this.referenceColorIndex);\n  }\n  validateAndSetOptions(options) {\n    if ('levelOffset' in options) {\n      if (typeof options.levelOffset !== 'number' || options.levelOffset <= 0) {\n        throw new Error(`levelOffset \"${options.levelOffset}\" must be a positive number representing the required relative heart rate divergence from the reference value for color change.`);\n      }\n      this.levelOffset = options.levelOffset;\n    } else {\n      this.levelOffset = 0.05;\n    }\n    if ('colorSteps' in options && options.colorSteps.length > 0) {\n      for (let color of options.colorSteps) {\n        if (!(0,_utility_js__WEBPACK_IMPORTED_MODULE_1__.isValidColor)(color)) {\n          throw new Error((0,_utility_js__WEBPACK_IMPORTED_MODULE_1__.noValidColorErrorMessage)(color));\n        }\n      }\n      this.colorSteps = options.colorSteps;\n    } else {\n      this.colorSteps = ['darkcyan', 'forestgreen', 'khaki', 'orange', 'red'];\n    }\n\n    // - Ensure referenceColorIndex is set\n    // - Confirm it's a positive integer\n    // - Verify it's within the range of available color steps\n    if (!options.referenceColorIndex || !(Number.isInteger(options.referenceColorIndex) && options.referenceColorIndex > 0) || options.referenceColorIndex > this.colorSteps.length - 1) {\n      if (this.colorSteps.length >= 3) {\n        this.referenceColorIndex = 1;\n      } else {\n        this.referenceColorIndex = 0;\n      }\n    } else {\n      this.referenceColorIndex = options.referenceColorIndex;\n    }\n    this.isAnimated = 'animated' in options ? Boolean(options.animated) : false;\n  }\n  draw() {\n    var y = this.maxY;\n    var svgBaseColor = this.getSVGBaseColor();\n    const svgCode = `\n        <svg width=\"100%\" height=\"100%\" viewBox=\"128 75 36 109\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n            <defs>\n            <clipPath id=\"bodyClip\">\n                <circle cx=\"146\" cy=\"98\" r=\"9.5\"/>\n                <path d=\"M132.244 148H133.6C135.809 148 137.6 149.791 137.6 152V178.964C137.6 182.067 140.98 183.988 143.646 182.401L143.954 182.218C145.215 181.467 146.785 181.467 148.046 182.218L148.354 182.401C151.02 183.988 154.4 182.067 154.4 178.964V152C154.4 149.791 156.191 148 158.4 148H159.756C162.058 148 163.885 146.062 163.749 143.764L161.973 113.764C161.848 111.65 160.097 110 157.98 110H134.02C131.903 110 130.152 111.65 130.027 113.764L128.251 143.764C128.115 146.062 129.942 148 132.244 148Z\"/>\n            </clipPath>\n            </defs>\n    \n        <g id=\"valueDisplay\" visibility=\"${this.valueVisible ? 'visible' : 'hidden'}\">\n            <text id=\"currentVal\" x=\"146\" y=\"80\" font-size=\"0.6em\" text-anchor=\"middle\" dominant-baseline=\"middle\" fill=\"${svgBaseColor}\" stroke=\"none\">0</text>\n        </g>\n        \n        <g id=\"filling\" clip-path=\"url(#bodyClip)\">\n            ${this.isAnimated ? `<path id=\"wave\" fill=\"transparent\" d=\"M128,${y} C134,${y} 140,${y} 146,${y} S158,${y} 164,${y} L164,616 L128,616 Z\"></path>` : `<rect id=\"fillBox\" x=\"128\" y=\"${y}\" width=\"36\" height=\"440\" fill=\"transparent\"></rect>`}                          \n        </g>\n    \n        <g id=\"stick_figure\" stroke=\"black\" stroke-width=\"1\"> \n            <circle id=\"head\" cx=\"146\" cy=\"98\" r=\"9.5\"/>\n            <path id=\"body\" d=\"M132.244 148H133.6C135.809 148 137.6 149.791 137.6 152V178.964C137.6 182.067 140.98 183.988 143.646 182.401L143.954 182.218C145.215 181.467 146.785 181.467 148.046 182.218L148.354 182.401C151.02 183.988 154.4 182.067 154.4 178.964V152C154.4 149.791 156.191 148 158.4 148H159.756C162.058 148 163.885 146.062 163.749 143.764L161.973 113.764C161.848 111.65 160.097 110 157.98 110H134.02C131.903 110 130.152 111.65 130.027 113.764L128.251 143.764C128.115 146.062 129.942 148 132.244 148Z\"/>\n        </g>\n        </svg>\n        `;\n    const tempDiv = document.createElement('div');\n    tempDiv.innerHTML = svgCode;\n    this.svgElement = tempDiv.firstElementChild;\n    this.container.appendChild(this.svgElement);\n\n    // start animation\n    if (this.isAnimated) {\n      requestAnimationFrame(this.animate);\n    }\n  }\n  update(heartRate) {\n    if (!this.svgElement) return;\n    const fillLevelY = this.calculateFillLevel(heartRate);\n    const fillColor = this.calculateFillColor(heartRate);\n    this.currentY = fillLevelY;\n    if (this.isAnimated) {\n      const wave = this.svgElement.querySelector(\"#wave\");\n      if (wave) {\n        wave.style.fill = fillColor;\n      }\n    } else {\n      const fillRect = this.svgElement.querySelector(\"#fillBox\");\n      if (fillRect) {\n        fillRect.setAttribute(\"y\", fillLevelY);\n        fillRect.setAttribute(\"fill\", fillColor);\n        fillRect.setAttribute(\"height\", `${this.maxY - fillLevelY + 440}`);\n      }\n    }\n\n    // Update the displayed value\n    const currentValue = this.svgElement.querySelector('#currentVal');\n    if (currentValue) {\n      currentValue.textContent = heartRate;\n    }\n  }\n  animate = () => {\n    this.updatePathWave();\n    requestAnimationFrame(this.animate);\n  };\n  updatePathWave() {\n    const path = this.svgElement.querySelector('#wave');\n    const width = 36;\n    const baseY = this.currentY;\n    const amplitude = 1.5;\n    const frequency = 1;\n    const calculateY = x => {\n      // phase value determines vertical movements of wave\n      return baseY + amplitude * Math.sin(frequency * x + this.phase);\n    };\n\n    // calculate points of the wave\n    const points = [];\n    const numPoints = 10; // number of points to determine smootheness of the animation\n    for (let i = 0; i <= width; i += width / (numPoints - 1)) {\n      points.push(`${128 + i},${calculateY(i)}`);\n    }\n\n    // create the path\n    const d = `M${points[0]} ` +\n    // select all points except the first and last and concatenate as string\n    `C${points.slice(1, -1).join(' ')} ` + `${points[points.length - 1]} ` + `L164,616 L128,616 Z`;\n    path.setAttribute('d', d);\n\n    // by increasing the phase value the vertical position of the points changes each frame\n    // this creates the illusion of a wave moving from right to left\n    this.phase += 0.05;\n    if (this.phase > 2 * Math.PI) {\n      this.phase -= 2 * Math.PI; // phase in [0, 2Ï€] to avoid numeric instability for increasing phase values\n    }\n  }\n\n  /**\n   * Calculates the y coordinate for drawing the fill level.\n   * \n   * @param {number} heartRate the value to calculate the fill level for.\n   * @returns the y coordinate for the fill level\n   */\n  calculateFillLevel(heartRate) {\n    // Using the number of levels and the offset needed to reach the next level\n    // the maximum and minimum heart rates that can be visualized are calculated.\n    var stepsAboveReference = this.colorSteps.length - 1 - this.referenceColorIndex;\n    var stepsBelowReference = this.referenceColorIndex;\n    var maxVisualizableHeartRate = this.referenceVal + this.referenceVal * this.levelOffset * (stepsAboveReference + 1);\n    var minVisualizableHeartRate = this.referenceVal - this.referenceVal * this.levelOffset * (stepsBelowReference + 1);\n    // now we can calculate the ratio of coordinates per heart rate divergence from reference\n    var heartRateRange = maxVisualizableHeartRate - minVisualizableHeartRate;\n    var coordinateRange = this.maxY - this.minY;\n    var coordinatePerHeartRate = coordinateRange / heartRateRange;\n    // the y value is calculated by using the determined ranges\n    var y = Math.min(Math.max(this.maxY - (heartRate - minVisualizableHeartRate) * coordinatePerHeartRate, this.minY), this.maxY);\n    return y;\n  }\n  calculateFillColor(heartRate) {\n    var offset;\n    var steps;\n    var color;\n    if (heartRate <= this.referenceVal) {\n      offset = (this.referenceVal - heartRate) / this.referenceVal;\n      steps = Math.floor(offset / this.levelOffset);\n      color = this.colorSteps[Math.max(this.referenceColorIndex - steps, 0)];\n    } else {\n      offset = (heartRate - this.referenceVal) / this.referenceVal;\n      steps = Math.floor(offset / this.levelOffset);\n      color = this.colorSteps[Math.min(this.referenceColorIndex + steps, this.colorSteps.length - 1)];\n    }\n    return color;\n  }\n}\n\n//# sourceURL=webpack://vitasight/./src/visualizations/heartRate/heartRateSketchFigure.js?");

/***/ }),

/***/ "./src/visualizations/heartRate/heartRateVisualization.js":
/*!****************************************************************!*\
  !*** ./src/visualizations/heartRate/heartRateVisualization.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HeartRateVisualization: function() { return /* binding */ HeartRateVisualization; }\n/* harmony export */ });\n/* harmony import */ var _visualization_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../visualization.js */ \"./src/visualizations/visualization.js\");\n\n\n/**\n * @abstract\n * base class for heart rate visualizations\n */\nclass HeartRateVisualization extends _visualization_js__WEBPACK_IMPORTED_MODULE_0__.Visualization {\n  /**\n   * \n   * @param {string} containerId - the id of the html element which will contain the heart rate visualization\n   */\n  constructor(containerId) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // surpresses the instantiation of abstract class\n    if (new.target === HeartRateVisualization) {\n      throw new TypeError(\"Cannot construct Abstract instances directly\");\n    }\n    super(containerId);\n    this.valueVisible;\n    this.referenceVal;\n    this.svgElement;\n    if ('referenceValue' in options) {\n      if (typeof options.referenceValue !== 'number' || options.referenceValue < 0) {\n        throw new Error('referenceValue must be a number that is at least 0');\n      }\n      this.referenceVal = options.referenceValue;\n    } else {\n      this.referenceVal = 70; //default value\n    }\n    this.valueVisible = 'valueVisible' in options ? Boolean(options.valueVisible) : false;\n  }\n\n  /**\n   * @abstract\n   * \n   * draws the heart rate visualization onto the screen\n   */\n  draw() {\n    throw new Error(\"Abstract method 'draw' can't be executed. Must be overridden in Subclass.\");\n  }\n\n  /**\n   * \n   * @param {number} heartRate - the new heart rate value to visualize\n   */\n  update(heartRate) {\n    throw new Error(\"Abstract method can't be executed. Must be overridden in Subclass.\");\n  }\n}\n\n//# sourceURL=webpack://vitasight/./src/visualizations/heartRate/heartRateVisualization.js?");

/***/ }),

/***/ "./src/visualizations/heartRate/historyLineGraph.js":
/*!**********************************************************!*\
  !*** ./src/visualizations/heartRate/historyLineGraph.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HistoryLineGraph: function() { return /* binding */ HistoryLineGraph; }\n/* harmony export */ });\n/* harmony import */ var _heartRateVisualization_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./heartRateVisualization.js */ \"./src/visualizations/heartRate/heartRateVisualization.js\");\n/* harmony import */ var _utility_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utility.js */ \"./src/visualizations/utility.js\");\n\n\n\nclass HistoryLineGraph extends _heartRateVisualization_js__WEBPACK_IMPORTED_MODULE_0__.HeartRateVisualization {\n  constructor(containerId) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(containerId, options);\n    this.minVal;\n    this.maxVal;\n    this.graphLineColor;\n    this.refLineColor;\n    this.numberTimestamps;\n    this.numberYIntercepts;\n    this.canvas = document.createElement('canvas');\n    this.ctx = this.canvas.getContext('2d');\n    this.container.appendChild(this.canvas);\n    this.data = []; // container for the data points\n\n    this.minTime = new Date();\n    this.maxTime = new Date();\n    this.validateAndSetOptions(options);\n    this.draw();\n  }\n  draw() {\n    // adjust canvas size to container size\n    this.updateCanvasSize();\n    const paddingFraction = 0.1; // 10% of the canvas height is used for padding\n    const padding = this.canvas.height * paddingFraction;\n    const zero = 0 + padding; // redfine zero of coordinate system to consider padding\n    const graphWidth = this.canvas.width - padding * 2;\n    const graphHeight = this.canvas.height - padding * 2;\n    const fontSize = graphHeight * 0.05; // font size is relative to canvas size to enhance responsitiviy\n\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n    // draw axis\n    this.ctx.beginPath();\n    this.ctx.moveTo(zero, zero);\n    this.ctx.lineTo(zero, zero + graphHeight);\n    this.ctx.lineTo(zero + graphWidth, zero + graphHeight);\n    this.ctx.stroke();\n\n    // draw reference line\n    const refY = zero + graphHeight * (1 - (this.referenceVal - this.minVal) / (this.maxVal - this.minVal));\n    this.ctx.beginPath();\n    this.ctx.strokeStyle = this.refLineColor;\n    this.ctx.setLineDash([2, 2]);\n    this.ctx.moveTo(zero, refY);\n    this.ctx.lineTo(zero + graphWidth, refY);\n    this.ctx.stroke();\n    this.ctx.setLineDash([]);\n\n    // calculate timestamps\n    const numberTimestamps = this.numberTimestamps;\n    const timestamps = [];\n    const timeDifference = this.maxTime.getTime() - this.minTime.getTime();\n    for (let i = 0; i < numberTimestamps; i++) {\n      const milliSecondOffset = i * timeDifference / (numberTimestamps - 1);\n      timestamps.push(new Date(this.minTime.getTime() + milliSecondOffset));\n    }\n    // draw timestamps on x axis\n    timestamps.forEach((timestamp, index) => {\n      const y = zero + graphHeight + fontSize * 0.5;\n      const x = zero + index * (graphWidth / (numberTimestamps - 1));\n      this.ctx.fillStyle = 'black';\n      this.ctx.font = `${fontSize}px Arial`;\n      this.ctx.textAlign = 'center';\n      this.ctx.textBaseline = 'top';\n      this.ctx.fillText(timestamp.toTimeString().split(' ')[0], x, y);\n    });\n\n    // draw y axis sections\n    this.ctx.textAlign = 'right';\n    this.ctx.textBaseline = 'middle';\n    for (let i = 0; i < this.numberYIntercepts; i++) {\n      const value = this.minVal + (this.maxVal - this.minVal) * i / (this.numberYIntercepts - 1);\n      const y = zero + graphHeight - (value - this.minVal) / (this.maxVal - this.minVal) * graphHeight;\n      this.ctx.fillText(parseInt(value), zero - fontSize * 0.5, y);\n    }\n\n    // draw data points\n    this.ctx.beginPath();\n    this.data.forEach((point, index) => {\n      // calculate coordinates for each point\n      const x = zero + (point.time - this.minTime) / (this.maxTime - this.minTime) * graphWidth;\n      const y = zero + graphHeight - (point.value - this.minVal) / (this.maxVal - this.minVal) * graphHeight;\n      if (index === 0) {\n        this.ctx.moveTo(x, y);\n      } else {\n        this.ctx.lineTo(x, y);\n      }\n    });\n    this.ctx.strokeStyle = `${this.graphLineColor}`;\n    this.ctx.stroke();\n  }\n  updateCanvasSize() {\n    var rect = this.canvas.parentNode.getBoundingClientRect();\n    // size of y axis is 70% of the size of x axis as a fixed proportion\n    this.canvas.height = Math.min(0.7 * rect.width, rect.height);\n    this.canvas.width = this.canvas.height / 0.7;\n  }\n  update(heartRate) {\n    if (this.data.length == 0) {\n      this.minTime = new Date();\n    }\n    // each value get's a time stamp attatched to it\n    const now = new Date();\n    this.maxTime = now;\n    // keep data points in the boundaries of the diagram\n    if (heartRate < this.minVal) {\n      heartRate = this.minVal;\n    } else if (heartRate > this.maxVal) {\n      heartRate = this.maxVal;\n    }\n    this.data.push({\n      value: heartRate,\n      time: now\n    });\n    this.draw();\n  }\n\n  // section of methods that validate the user input\n\n  /**\n   * Method to validate the user input\n   * @param {Object} options \n   */\n  validateAndSetOptions(options) {\n    if (options.numberTimestamps) {\n      if (Number.isInteger(options.numberTimestamps)) {\n        this.numberTimestamps = options.numberTimestamps;\n      } else {\n        this.numberTimestamps = 5;\n        console.error(`Parameter numberTimestamps must be integer. Input was '${options.numberTimestamps}'. Value is set to default value 5.`);\n      }\n    } else {\n      this.numberTimestamps = 5;\n    }\n    if (options.numberYIntercepts) {\n      if (Number.isInteger(options.numberYIntercepts)) {\n        this.numberYIntercepts = options.numberYIntercepts;\n      } else {\n        this.numberYIntercepts = 5;\n        console.error(`Parameter numberYIntercepts must be integer. Input was '${options.numberYIntercepts}'. Value is set to default value 5.`);\n      }\n    } else {\n      this.numberYIntercepts = 5;\n    }\n    this.validateColors(options);\n    this.validateMinAndMaxValue(options);\n  }\n  validateColors(options) {\n    if ('referenceLineColor' in options) {\n      if ((0,_utility_js__WEBPACK_IMPORTED_MODULE_1__.isValidColor)(options.referenceLineColor)) {\n        this.refLineColor = options.referenceLineColor;\n      } else {\n        console.error((0,_utility_js__WEBPACK_IMPORTED_MODULE_1__.noValidColorErrorMessage)(options.referenceLineColor));\n      }\n    } else {\n      this.refLineColor = \"red\"; // default value\n    }\n    if ('graphLineColor' in options) {\n      if ((0,_utility_js__WEBPACK_IMPORTED_MODULE_1__.isValidColor)(options.graphLineColor)) {\n        this.graphLineColor = options.graphLineColor;\n      } else {\n        console.error((0,_utility_js__WEBPACK_IMPORTED_MODULE_1__.noValidColorErrorMessage)(options.graphLineColor));\n      }\n    } else {\n      this.graphLineColor = \"blue\"; // default value\n    }\n  }\n  validateMinAndMaxValue(options) {\n    const defaultMinVal = 40;\n    const defaultMaxVal = 180;\n    if ('minValue' in options) {\n      if (typeof options.minValue !== 'number' || options.minValue < 0) {\n        console.error('minValue must be a number that is at least 0');\n      }\n      this.minVal = options.minValue;\n    } else {\n      this.minVal = defaultMinVal;\n    }\n    if ('maxValue' in options) {\n      if (typeof options.minValue !== 'number' || options.maxValue < 1) {\n        console.error('maxValue must be a number that is at least 1');\n      }\n      this.maxVal = options.maxValue;\n    } else {\n      this.maxVal = defaultMaxVal;\n    }\n    if (this.minVal > this.maxVal) {\n      var errorMessage = `Minimum value ${this.minVal} must not be larger than maximum value ${this.maxVal}. Minimum value is set to default=${defaultMinVal} and maximum value to default=${defaultMaxVal}`;\n      this.minVal = defaultMinVal;\n      this.maxVal = defaultMaxVal;\n      console.error(errorMessage);\n    }\n    if (this.referenceVal < this.minVal || this.referenceVal > this.maxVal) {\n      var errorMessage = `Reference value ${this.referenceVal} must be between minimum value ${this.minVal} and maximum value ${this.maxVal}`;\n      this.referenceVal = this.minVal + (this.maxVal - this.minVal) / 2; // set reference value right in the middle\n      console.error(errorMessage);\n    }\n  }\n}\n\n//# sourceURL=webpack://vitasight/./src/visualizations/heartRate/historyLineGraph.js?");

/***/ }),

/***/ "./src/visualizations/heartRate/pulsatingHeart.js":
/*!********************************************************!*\
  !*** ./src/visualizations/heartRate/pulsatingHeart.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PulsatingHeart: function() { return /* binding */ PulsatingHeart; }\n/* harmony export */ });\n/* harmony import */ var _heartRateVisualization_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./heartRateVisualization.js */ \"./src/visualizations/heartRate/heartRateVisualization.js\");\n/* harmony import */ var _utility_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utility.js */ \"./src/visualizations/utility.js\");\n\n\n\nclass PulsatingHeart extends _heartRateVisualization_js__WEBPACK_IMPORTED_MODULE_0__.HeartRateVisualization {\n  constructor(containerId) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(containerId, options);\n    this.scaleFactor;\n    this.heartColor;\n    this.isAnimated;\n    this.validateAndSetOptions(options);\n    this.lastHeartRate;\n    this.draw();\n    if (this.isAnimated) {\n      this.setupAnimationListeners();\n    }\n  }\n  validateAndSetOptions(options) {\n    if ('scaleFactor' in options) {\n      if (typeof options.scaleFactor !== 'number' || options.scaleFactor < 1) {\n        throw new Error('scaleFactor must be a number that is at least 1');\n      }\n      this.scaleFactor = options.scaleFactor;\n    } else {\n      this.scaleFactor = 1.5;\n    }\n    if ('heartColor' in options) {\n      if ((0,_utility_js__WEBPACK_IMPORTED_MODULE_1__.isValidColor)(options.heartColor)) {\n        this.heartColor = options.heartColor;\n      } else {\n        throw new Error((0,_utility_js__WEBPACK_IMPORTED_MODULE_1__.noValidColorErrorMessage)(options.heartColor));\n      }\n    } else {\n      this.heartColor = \"red\"; // default value\n    }\n    this.isAnimated = 'animated' in options ? Boolean(options.animated) : true;\n  }\n  draw() {\n    const svgBaseColor = this.getSVGBaseColor();\n    const viewBoxHeight = 32;\n    /**\n     * A heart.\n     * Animation that scales the heart to ressemble a heart beat.\n     * The timespan between consecutive scaling animations depends on the heart rate.\n     * After three scaling animations the timespan ('dur') is updated to consider the most recent heart rate.\n     */\n    const svgCode = `\n        <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\" viewBox=\"-14 -14 28 ${viewBoxHeight}\">\n            <path id=\"pulsatingHeart\" \n                d=\"M3.7 -8C6.87 -8 9 -5.02 9 -2.24C9 3.39 0.16 8 0 8C-0.16 8 -9 3.39 -9 -2.24C-9 -5.02 -6.87 -8 -3.7 -8C-1.88 -8 -0.69 -7.09 0 -6.29C0.69 -7.09 1.88 -8 3.7 -8Z\"\n                stroke-linecap=\"round\" stroke-linejoin=\"round\"\n                fill=\"${this.heartColor}\">\n                ${this.isAnimated ? `<animateTransform\n                    id=\"pulseAnimation\"\n                    attributeName=\"transform\"\n                    attributeType=\"XML\"\n                    type=\"scale\"\n                    from=\"1\"\n                    to=\"${this.scaleFactor}\"\n                    dur=\"\"\n                    repeatCount=\"3\"\n                    keyTimes=\"0;0.5;1\"\n                    values=\"1;${this.scaleFactor};1\"\n                    begin=\"indefinite\"\n                />` : ``}               \n            </path>\n            <g id=\"valueDisplay\" visibility=\"${this.valueVisible ? 'visible' : 'hidden'}\">\n                <text id=\"currentVal\" x=\"0\" y=\"${viewBoxHeight / 2}\" font-size=\"0.3em\" text-anchor=\"middle\" dominant-baseline=\"middle\" fill=\"${svgBaseColor}\" stroke=\"none\">0</text>\n            </g>\n        </svg>\n        `;\n    // get safe reference to the svg element of the instance to avoid naming conflicts with other DOM elements\n    const tempDiv = document.createElement('div');\n    tempDiv.innerHTML = svgCode;\n    const newSvg = tempDiv.firstElementChild;\n    this.svgElement = newSvg;\n    this.container.appendChild(newSvg);\n  }\n  update(heartRate) {\n    this.lastHeartRate = heartRate;\n    if (this.valueVisible) {\n      this.updateValueDisplay(heartRate);\n    }\n\n    // with the receival of the first heart rate value the animation is started\n    if (this.isAnimated && !this.isAnimationRunning) {\n      this.restartAnimation();\n    }\n  }\n  updateValueDisplay(heartRate) {\n    if (this.svgElement) {\n      const valueDisplay = this.svgElement.querySelector('#currentVal');\n      if (valueDisplay) {\n        valueDisplay.textContent = heartRate;\n      }\n    }\n  }\n\n  /**\n   * restarts the animation for 3 beats with the most recent heart rate value\n   */\n  restartAnimation() {\n    const animation = this.getAnimation();\n    // in case an error occurs with measuring the heart rate, than the value by which to divide\n    // must not be zero or to small cause otherwise animation will basically stop\n    const newDuration = 60 / Math.max(this.lastHeartRate, 20);\n    animation.endElement();\n    animation.setAttribute('dur', newDuration + \"s\");\n    animation.beginElement();\n  }\n\n  /**\n   * creates event listeners of animation events\n   */\n  setupAnimationListeners() {\n    const animation = this.getAnimation();\n\n    // if the animation ends it must be restarted with the current heart rate value\n    animation.addEventListener(\"endEvent\", () => {\n      this.restartAnimation();\n    });\n    animation.addEventListener('beginEvent', () => {\n      this.isAnimationRunning = true;\n    });\n  }\n  getAnimation() {\n    const animation = document.getElementById('pulseAnimation');\n    if (!animation) {\n      console.error(\"Animation element not found\");\n      return;\n    }\n    return animation;\n  }\n}\n\n//# sourceURL=webpack://vitasight/./src/visualizations/heartRate/pulsatingHeart.js?");

/***/ }),

/***/ "./src/visualizations/heartRate/screenOverlay.js":
/*!*******************************************************!*\
  !*** ./src/visualizations/heartRate/screenOverlay.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScreenOverlay: function() { return /* binding */ ScreenOverlay; }\n/* harmony export */ });\n/* harmony import */ var _heartRateVisualization_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./heartRateVisualization.js */ \"./src/visualizations/heartRate/heartRateVisualization.js\");\n/* harmony import */ var _utility_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utility.js */ \"./src/visualizations/utility.js\");\n\n\n\nconst FULL_SCREEN_DIV_ID = 'vignetteFullScreen';\nclass ScreenOverlay extends _heartRateVisualization_js__WEBPACK_IMPORTED_MODULE_0__.HeartRateVisualization {\n  constructor() {\n    let containerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (containerId) {\n      super(containerId, options);\n    } else {\n      const div = document.createElement('div');\n      div.setAttribute('id', FULL_SCREEN_DIV_ID);\n      div.setAttribute('style', `position:fixed;\n                top:0;\n                left:0;\n                width:100%;\n                height:100%;\n                pointer-events:none;`);\n      document.body.appendChild(div);\n      super(div.getAttribute('id'), options);\n    }\n    this.color;\n    this.maxVal;\n    this.tunnelIntensity;\n\n    // allows the vignette/tunnel effect to be scroll independent\n    // this.container.style.position = 'fixed';\n    // this.container.style.top = 0;\n    // this.container.style.left = 0;\n    // how much the shadow fades as opposed to sharp edges\n    this.shadowBlur;\n    this.validateAndSetOptions(options);\n  }\n  getFullScreenDiv() {\n    const div = document.createElement('div');\n    div.setAttribute('id', FULL_SCREEN_DIV_ID);\n    div.setAttribute('style', `position:fixed;\n            top:0;\n            left:0;\n            width:100%;\n            height:100%;\n            pointer-events:none; \n            z-index:9999;`);\n    // high z-index to make sure the div is lowest element and doesn't hide other divs\n    return div;\n  }\n  validateAndSetOptions(options) {\n    if ('color' in options) {\n      if (!(0,_utility_js__WEBPACK_IMPORTED_MODULE_1__.isValidColor)(options.color)) {\n        this.color = \"rgba(0,0,0,\";\n        throw new Error(_utility_js__WEBPACK_IMPORTED_MODULE_1__.noValidColorErrorMessage + \". Default color is black.\");\n      } else {\n        this.color = this.transformColor(options.color);\n      }\n    }\n    if ('maxValue' in options) {\n      if (options.maxValue <= this.referenceVal) {\n        this.maxVal = Math.max(this.referenceVal + 20, 140);\n        throw new Error(`maxValue '${options.maxValue}' must not be smaller than referenceValue '${this.referenceVal}' and is therefore set to '${this.maxVal}'.`);\n      } else {\n        this.maxVal = options.maxValue;\n      }\n    }\n    const tunnelIntensityDefault = 0.1;\n    if ('tunnelIntensity' in options) {\n      if (typeof options.tunnelIntensity !== \"number\" || options.tunnelIntensity < 0 || options.tunnelIntensity > 1) {\n        this.tunnelIntensity = tunnelIntensityDefault;\n        throw new Error(`tunnelIntensity '${options.tunnelIntensity}' must be a input between 0 and 1. It is now set to the default value 0.1`);\n      } else {\n        // user has the posibility to declare intuitiv values between 0 and 1\n        // but only values in (0, 0.1] are usefull\n        this.tunnelIntensity = options.tunnelIntensity / 10;\n      }\n    } else {\n      this.tunnelIntensity = tunnelIntensityDefault;\n    }\n  }\n\n  /**\n   * Converts a color into rgb and than fills the rgb values in an rgba template,\n   * which is necessary to set opacity of background-shadow.\n   * @param {*} color \n   * @returns rgba template with rgb color values prefilled.\n   */\n  transformColor(color) {\n    const tempDiv = document.createElement(\"div\");\n    tempDiv.style.color = color;\n    document.body.appendChild(tempDiv);\n\n    // Get rgb color value of div\n    const cs = getComputedStyle(tempDiv);\n    const rgbColor = cs.getPropertyValue(\"color\");\n\n    // Remove div after obtaining desired color value\n    document.body.removeChild(tempDiv);\n    let r, g, b;\n    const match = rgbColor.match(/(\\d+),\\s*(\\d+),\\s*(\\d+)/);\n    r = parseInt(match[1]);\n    g = parseInt(match[2]);\n    b = parseInt(match[3]);\n    return `rgba(${r}, ${g}, ${b},`;\n  }\n  draw() {\n    return;\n  }\n  update(heartRate) {\n    console.log('is updated');\n    const containerWidth = this.getContainerWidth();\n    const containerDiv = this.container;\n    const shadowSpread = this.calculateShadowSpread(heartRate, containerWidth);\n    const shadowBlur = this.calculateShadowBlur(containerWidth);\n    const shadowOpacity = this.calculateShadowOpacity(heartRate);\n    const def = `0 0 ${shadowBlur}em ${shadowSpread}px ${this.color + shadowOpacity}) inset`;\n    console.log(def);\n    containerDiv.style.boxShadow = def;\n    console.log(containerDiv.style.boxShadow);\n  }\n  getContainerWidth() {\n    const containerSize = this.container.getBoundingClientRect();\n    const conatinerWidth = containerSize.width;\n    return conatinerWidth;\n  }\n  calculateShadowBlur(containerWidth) {\n    const shadowBlur = Math.pow(containerWidth, 0.8) * 0.02;\n    console.log(shadowBlur);\n    return shadowBlur;\n  }\n  calculateShadowSpread(heartRate, containerWidth) {\n    const positiveRelativeOffset = Math.max(0, (heartRate - this.referenceVal) / (this.maxVal - this.referenceVal));\n    const shadowSpread = positiveRelativeOffset * containerWidth * this.tunnelIntensity;\n    return shadowSpread;\n  }\n  calculateShadowOpacity(heartRate) {\n    const positiveRelativeOffset = Math.max(0, (heartRate - this.referenceVal) / (this.maxVal - this.referenceVal));\n    const shadowOpacity = positiveRelativeOffset;\n    return shadowOpacity;\n  }\n}\n\n//# sourceURL=webpack://vitasight/./src/visualizations/heartRate/screenOverlay.js?");

/***/ }),

/***/ "./src/visualizations/utility.js":
/*!***************************************!*\
  !*** ./src/visualizations/utility.js ***!
  \***************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isValidColor: function() { return /* binding */ isValidColor; },\n/* harmony export */   noValidColorErrorMessage: function() { return /* binding */ noValidColorErrorMessage; }\n/* harmony export */ });\nfunction isValidColor(colorName) {\n  const style = new Option().style;\n  style.color = colorName;\n  // if browser accepts color string it will be set as attribute\n  return style.color !== '';\n}\nconst noValidColorErrorMessage = color => `${color} is not a supported color declaration`;\n\n//# sourceURL=webpack://vitasight/./src/visualizations/utility.js?");

/***/ }),

/***/ "./src/visualizations/visualization.js":
/*!*********************************************!*\
  !*** ./src/visualizations/visualization.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Visualization: function() { return /* binding */ Visualization; }\n/* harmony export */ });\n/**\n * @abstract\n * base class for Visualizations\n */\nclass Visualization {\n  /**\n   * \n   * @param {string} containerId - the id of the html element which will contain the visualization\n   */\n  constructor(containerId) {\n    // surpresses the instantiation of abstract class\n    if (new.target === Visualization) {\n      console.error(\"Cannot construct Abstract instances directly\");\n    }\n    this.container = document.getElementById(containerId);\n    if (!this.container) {\n      console.error(`Container with id \"${containerId}\" not found!`);\n    }\n  }\n\n  /**\n   * @abstract\n   * \n   * @param {Object} options - visualization specific options to define it's attributes\n   * \n   */\n  validateAndSetOptions(options) {\n    throw new Error(\"Abstract method 'validateAndSetOptions' can't be executed. Must be overridden in Subclass.\");\n  }\n\n  /**\n   * @abstract\n   * \n   * draws the visualization onto the screen\n   */\n  draw() {\n    throw new Error(\"Abstract method 'draw' can't be executed. Must be overridden in Subclass.\");\n  }\n\n  /**\n   * @abstract\n   * \n   * @param {*} data - New information to be displayed in the visualization\n   */\n  update(data) {\n    throw new Error(\"Abstract method 'update' can't be executed. Must be overridden in Subclass.\");\n  }\n\n  // folgende zwei Methoden in utility Klasse auslagern\n\n  /**\n   * Determines wheter black of white provides more contrast considering the containers color\n   * @returns black or white depending on what provides better contrast\n   */\n  getSVGBaseColor() {\n    var backgroundColor = this.findBackgroundColor(this.container);\n    var colorBrightness = this.getColorBrightness(backgroundColor);\n    // bright colors will result in black being used for certain svg elements\n    var svgBaseColor = colorBrightness > 0.25 ? 'black' : 'white';\n    return svgBaseColor;\n  }\n\n  /**\n   * helper method to find optical background color of an element\n   * if background is fully transparent method will recursively iterate \n   * through parents to find optical background color.\n   * @param {object} element \n   * @returns rgb value of background color\n   */\n  findBackgroundColor(element) {\n    // if element non existent then return white background-color\n    const rgbWhite = 'rgb(255,255,255)';\n    if (!element) {\n      return rgbWhite;\n    }\n    const backgroundColor = window.getComputedStyle(element).backgroundColor;\n    if (backgroundColor == 'rgba(0, 0, 0, 0)') {\n      // recursively call method on parent if it is not already the root\n      if (element !== document.documentElement) {\n        return this.findBackgroundColor(element.parentElement);\n      } else {\n        return rgbWhite;\n      }\n    } else {\n      // currently visible background color of input element\n      return backgroundColor;\n    }\n  }\n\n  /**\n   * Determines the brightness of a given color in rgb format\n   * @param {string} rgbColor the color which brightness to determine in rgb format \n   * @returns value between in [0, 1] representing the colors brightness, where 1 is the brightest\n   */\n  getColorBrightness(rgbColor) {\n    let r, g, b;\n    const match = rgbColor.match(/(\\d+),\\s*(\\d+),\\s*(\\d+)/);\n    r = parseInt(match[1]);\n    g = parseInt(match[2]);\n    b = parseInt(match[3]);\n\n    // formula to calculate color brightness from https://www.w3.org/TR/AERT/#color-contrast\n    return (0.299 * r + 0.587 * g + 0.114 * b) / 255;\n  }\n}\n\n//# sourceURL=webpack://vitasight/./src/visualizations/visualization.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	vitasight = __webpack_exports__;
/******/ 	
/******/ })()
;